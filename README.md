# LearnGitForQA
This repo is created for learning GIT and its features for QA.

Terminal Git

git --help - справочная информация
touch some.file - создает файл в текущей папке
echo "Third line" >> some.file - создает строку в в файле
cat some.file - выводит содержимое файла на экран
git status - показывает статус гита
git add some.file - добавляет файл в локальный репозиторий для отслеживания
git commit -m "Here you can put description of commit" -  снимок отслеживаемого файла
git push - загрузить файлы на удаленный репозиторий (origin)
git fetch - показывает есть ли отличия между удаленным репозиторием и локальным
git pull -  загружает файлы с удаленного репозитория на локальный для синхронизации 
git log - показывает хронологию изменений
git log --author Didrich - показывает коммиты определенного автора
git show c9d563f93d131eacb2c1317564ea8a6198d387c2 - показывает коммиты с определенным хэш-ключем
git show - показывает последний коммит в репо
git blame some.file - показывает автора файла
blame some.file | grep awesome - показывает автора строки awesome в файле
blame some.file | grep Didar - показывает какие изменения вносил автор в файл
git diff - показывает отличия между удаленным репозиторием (точнее его снимком - origin/master) и локальным репозиторием (master).
git commit -a -m "some text" - коммит всех отслеживаемых файлов
git head - указывает, какая ветка у нас текущая и какой коммит в ней последний
git reset - может двигать указатель на несколько позиций
git reset HEAD~1 - двигает указатель на 1 позицию и разбирает последний коммит, т.е. файлы этого коммита не будут отслеживаться. Это можно проверить при помощи git log - коммит пропал из истории.
git reset HEAD~1 --hard - позволяет не только передвинуть указатель, но удалить файлы или внесенные изменения коммита
git commit --amend - для того, что бы работать с текущим коммитом, нужно добавить --amend,  что бы внести изменения в текущий каммит
git merge --abort - ключ аборт позволяет отменить каммит в случае конфликта между ветками. Конфликт останется, но м.б. мердж будет делать синьеры с правами доступа.

Если нужно решить конфликт самому, то нужно открыть файл и удалить строки, созданные гитом, а так же выбрать какие изменения - локальные или удаленные, нужно оставить. После этого в терминале набрать git add some.file и потом запустить команду git merge.

git checkout some.file - (Прим. файл изменен, git diff показывает, что в файл добавлена новая строка) команда возвращает файл к состоянию, в котором он был до начала изменения
git checkout . - отменяет все предыдущие изменения

git stash - команда временно удаляет изменения. Репозиторий будет чист и можно работать с ним, вносить изменения. Когда нужно будет отменить удаление воспользуйтесь командой git stash pop. Если файлы больше не нужны и их не требуется восстанавливать, тогда можно очистить память git stash командой git stash clear

Если в файле внесены изменения, а потом изменения убрали с помощью git stash, то повторное внесение изменения в этот файл не позволят сделать git stash pop. Причина та же - конфликт между версиями. Для удаления файлов в stash, можно воспользоваться командой git reset HEAD some.file, которая передвигает указатель. При этом сами изменения в файле останутся и их нужно будет удалить либо в ручную через редактор, либо через git checkout some.file

Теперь нам надо сохранить патч, который нельзя выкладывать в репозиторий. Создадим изменения: echo "Patch changes" >> some.file. Воспользуемся командой git diff >> some.patch и с помощью git checkout some.file удалим все изменения. Т.о. в статусе гита остался 1 неотслеживаемый файл - some.patch. Позже с помощью команды git apply some.patch можно вернуть изменения "Patch changes" в файл some.file. Удаляем файл rm some.patch

Ветвление
Название веток нужно писать со строчной буквы и слова разделять нижним подчеркиванием (this_is_new_branch).
git branch learn_branch - создаем новую ветку learn_branch и с помощью команды git branch можем увидеть, что новая ветка появилась. Текущая ветка помечена звездочкой. Переключится на новую ветку можно командой git checkout learn_branch. Далее вносим изменения в новой ветке, делаем коммит и после git push появляется ошибка - на сервере нет такой ветки. Для создания новой ветки нужно ввести команду git push --set-upstream origin learn_branch или сокращенную команду git push -u origin learn_branch
"git checkout -" - команда для перехода в предыдущую ветку, т.е. вместо названия ветки можно поставить минус.

Слияние ветки с основной веткой. Нужно перейти в основную ветку git checkout main. Затем выполнить слияние с веткой git merge branch_for_new_file. Запушить на origin. Если на origin есть изменения (коммиты от коллег), то сначала нужно сделать git pull, затем git push.

Переименование ветки. 
(до отправки на удаленный репо). Создаем новую ветку: git branch change_my_name. С помощью ключа -m меняем имя ветки: git branch -m change_my_name name_changed.
(после отправки на удаленный репо). Переходим в новую ветку git checkout name_changed. Создаем новый файл touch add_branch_to_origin.file. Выполняем git add add_branch_to_origin.file, затем git commit -am "push file to cteate branch", пушим git push -u origin name_changed. Потом локально меняем название ветки git branch -m name_changed change_my_name_new. Удаляем ветку на удаленном репозитории git push origin :name_changed. Пушим переименованную ветку git push -u origin change_my_name_new.

Удаление ветки.
Локально. переходим в основную ветку git checkout main. Удаляем ненужную ветку git branch -d branch_for_new_file. 
Вернуть ветку можно скачав ее с удаленного репозитория. С помощью команды git fetch origin branch_for_new_file получаем удаленную ветку, выполняем git checkout branch_for_new_file для переноса ее файлы. Теперь можно вернутся в основную ветку.

Работа с untracked files.
Создаем несколько новых файлов - touch 1.file, touch 2.file... touch 5.file, затем с помощью git add . добавляем их вместе (ключ "точка"). Если один из файлов был добавлен по ошибке, то с помощью git reset HEAD 1.file удаляем его и он в git status отображается как Untracked files. Либо удалить все файлы разом с помощью git reset HEAD . (ключ "точка"). И с помощью git clean -f их можно удалить так же все разом.

.gitignore
Создаем несколько новых файлов - touch 1.file, touch 2.file... touch 5.file, затем с помощью echo 1.file > .gitignore добавляем один файл в gitignore. Теперь этот файл не отображается в Untracked files.

Создаем новую папку mkdir my_dir. Перемещаем туда файлы mv 1.file my_dir, mv 2.file my_dir, mv 3.file my_dir, mv 4.file my_dir, mv 5.file my_dir. Проверяем git status, видим Untracked files: my_dir. Добавляем git add my_dir. Можно отменить добавление  с помощью git reset HEAD. И удалить файлы из директории git clean -f -d. Как видно файл 1.file не был удален, так как находится в .gitignore. Перемещаем его в предыдущую папку с помощью mv my_dir/1.file . (ключ "точка"). и теперь команда git clean -fd удаляет также и директорию my_dir.

Поиск по содержимому - grep
git grep Line показывает в каких файлах есть слово Line. Если нужно узнать номер строки, то нужно добавить ключ -n: git grep -n Line. Узнать сколько раз встречается это слово git grep -c Line. Поиск по нескольким значениям можно делать с ключом -e git grep -e something -e Line. Для игнорирования регистра используется ключ -i: git grep -i line. Справка git grep --help

Редактируем файл .gitconfig
Смотрим содержимое файла cat ~/.gitconfig. Переходим в /Users/didar/.gitconfig. Добавляем цвета:
[color]
	diff = auto
	status = auto
[color "status"]
	added = yellow
	changed = green
	untracked = blue
[color "diff"]
	old = red bold
	new = green bold
Также в .gitconfig можно задать алиасы - сокращения для команд, а также переопределять команды и подставлять в них параметры. Некоторые команды используются часто - checkout, commit, status и т.д. Они задаются в config-файлах. Можно задать алиасы в .gitconfig. Добавляем строки в .gitconfig: 
[alias] 
	co = checkout
	ci = commit
	st = status
	br = branch
Теперь команда git st выполнит команду git status.

В каждом локальном репозитории есть скрытая информация cat .git/config. Инфа о репозитории, адресе удаленного репо, названии веток. Вносим изменение [user] email=new@email.com. Теперь делаем новый коммит и видим, что в git log адрес почты поменялся.


